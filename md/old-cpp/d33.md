### 1. Introduction
Custom memory allocators provide better control over memory management, optimizing performance for specific use cases. They can help reduce fragmentation, speed up allocation, and improve memory usage efficiency.

### 2. Why Use a Custom Allocator?
- Improve performance for frequent allocations.
- Reduce heap fragmentation.
- Enable memory pooling for efficient resource reuse.
- Implement domain-specific memory management strategies.

### 3. Basic Custom Allocator Implementation
A simple allocator manages memory blocks using a preallocated buffer.

#### **3.1 Example: Simple Custom Allocator**
```c
#include <iostream>
#include <vector>
#include <cstdlib>
using namespace std;

class SimpleAllocator {
private:
    size_t blockSize;
    vector<void*> freeBlocks;
public:
    SimpleAllocator(size_t size) : blockSize(size) {}

    void* allocate() {
        if (!freeBlocks.empty()) {
            void* ptr = freeBlocks.back();
            freeBlocks.pop_back();
            return ptr;
        }
        return malloc(blockSize);
    }

    void deallocate(void* ptr) {
        freeBlocks.push_back(ptr);
    }

    ~SimpleAllocator() {
        for (void* ptr : freeBlocks) {
            free(ptr);
        }
    }
};

int main() {
    SimpleAllocator allocator(sizeof(int));
    int* num = static_cast<int*>(allocator.allocate());
    *num = 42;
    cout << "Allocated value: " << *num << endl;
    allocator.deallocate(num);
    return 0;
}
```

### 4. Memory Pool Allocator
A memory pool preallocates a fixed block of memory and manages allocations within it.

#### **4.1 Example: Pool Allocator**
```c
#include <iostream>
#include <vector>
using namespace std;

class PoolAllocator {
private:
    vector<char> memoryPool;
    size_t offset;
    size_t poolSize;
public:
    PoolAllocator(size_t size) : poolSize(size), offset(0) {
        memoryPool.resize(size);
    }

    void* allocate(size_t size) {
        if (offset + size > poolSize) {
            throw bad_alloc();
        }
        void* ptr = &memoryPool[offset];
        offset += size;
        return ptr;
    }
};

int main() {
    PoolAllocator allocator(1024);
    int* num = static_cast<int*>(allocator.allocate(sizeof(int)));
    *num = 100;
    cout << "Allocated from pool: " << *num << endl;
    return 0;
}
```

### 5. Overloading Global `new` and `delete`
Custom allocators can override global `new` and `delete`.

```c
void* operator new(size_t size) {
    cout << "Custom new for size: " << size << endl;
    return malloc(size);
}

void operator delete(void* ptr) noexcept {
    cout << "Custom delete called" << endl;
    free(ptr);
}
```

### 6. Best Practices
- Use memory pools for frequent small allocations.
- Align memory properly for performance.
- Avoid memory fragmentation.
- Monitor memory usage to prevent leaks.

### 7. Conclusion
Custom memory allocators provide fine-grained control over memory management, enhancing performance and efficiency. Implementing techniques like memory pooling, freelists, and overriding global allocators helps in optimizing memory usage for various applications.

