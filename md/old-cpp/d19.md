### 1. Encapsulation
Encapsulation is the practice of bundling data and methods within a class while restricting direct access to the data.

#### **1.1 Example of Encapsulation**
```c
#include <iostream>
using namespace std;

class Person {
private:
    int age;
public:
    void setAge(int a) {
        if (a > 0) age = a;
    }
    int getAge() {
        return age;
    }
};

int main() {
    Person p;
    p.setAge(25);
    cout << "Age: " << p.getAge() << endl;
    return 0;
}
```

**Key Points:**
- Data is hidden using `private`.
- Access is controlled using `public` methods.

### 2. Inheritance
Inheritance allows a class to acquire properties and behaviors from another class, promoting code reuse.

#### **2.1 Example of Inheritance**
```c
#include <iostream>
using namespace std;

class Vehicle {
public:
    void showType() {
        cout << "I am a vehicle." << endl;
    }
};

class Car : public Vehicle {
public:
    void showBrand() {
        cout << "I am a car." << endl;
    }
};

int main() {
    Car myCar;
    myCar.showType();
    myCar.showBrand();
    return 0;
}
```

**Types of Inheritance:**
- **Single Inheritance**: One class inherits from another.
- **Multiple Inheritance**: A class inherits from multiple base classes.
- **Multilevel Inheritance**: A derived class serves as a base class for another class.
- **Hierarchical Inheritance**: Multiple derived classes inherit from a single base class.
- **Hybrid Inheritance**: A combination of two or more types of inheritance.

### 3. Polymorphism
Polymorphism allows methods to take multiple forms. It is achieved using function overloading and method overriding.

#### **3.1 Function Overloading (Compile-time Polymorphism)**
```c
#include <iostream>
using namespace std;

class Math {
public:
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) {
        return a + b;
    }
};

int main() {
    Math m;
    cout << "Sum (int): " << m.add(5, 3) << endl;
    cout << "Sum (double): " << m.add(2.5, 3.5) << endl;
    return 0;
}
```

#### **3.2 Method Overriding (Runtime Polymorphism)**
```c
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void makeSound() {
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* a;
    Dog d;
    a = &d;
    a->makeSound();
    return 0;
}
```

### 4. Abstraction
Abstraction hides implementation details and exposes only essential functionalities.

#### **4.1 Example of Abstraction using Abstract Classes**
```c
#include <iostream>
using namespace std;

class Shape {
public:
    virtual void draw() = 0; // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a Circle" << endl;
    }
};

int main() {
    Shape* shape = new Circle();
    shape->draw();
    delete shape;
    return 0;
}
```

**Key Points:**
- Abstract classes contain at least one pure virtual function.
- Objects of abstract classes cannot be created directly.

---
Understanding encapsulation, inheritance, polymorphism, and abstraction is essential for mastering object-oriented programming in C++. These concepts improve code organization, reusability, and maintainability.

