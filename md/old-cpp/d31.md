### 1. Introduction
Pointers in C++ provide powerful memory management capabilities but can introduce issues like **dangling pointers** and **null pointer dereferencing** if not handled properly.

### 2. Dangling Pointers
A **dangling pointer** is a pointer that refers to a memory location that has been freed or is no longer valid.

#### **2.1 Causes of Dangling Pointers**
- **Deleting a pointer but still using it**
- **Returning a pointer to a local variable**
- **Uninitialized pointers**

#### **2.2 Example of a Dangling Pointer**
```c
#include <iostream>
using namespace std;

void danglingPointer() {
    int* ptr = new int(42);
    delete ptr; // Memory is freed
    cout << *ptr; // Undefined behavior (dangling pointer)
}

int main() {
    danglingPointer();
    return 0;
}
```

#### **2.3 Preventing Dangling Pointers**
- **Set pointers to `nullptr` after deleting**
- **Use smart pointers (`unique_ptr`, `shared_ptr`)**

```c
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Safe practice
```

### 3. Null Pointers
A **null pointer** is a pointer that does not point to any valid memory address. Accessing a null pointer leads to segmentation faults.

#### **3.1 Declaring and Checking Null Pointers**
```c
#include <iostream>
using namespace std;

int main() {
    int* ptr = nullptr; // Correct way to initialize null pointer
    if (!ptr) {
        cout << "Pointer is null" << endl;
    }
    return 0;
}
```

### 4. Best Practices
| Issue | Solution |
|-------|----------|
| Dangling pointers | Set pointer to `nullptr` after `delete` |
| Uninitialized pointers | Always initialize pointers |
| Null pointer dereferencing | Check for `nullptr` before dereferencing |

### 5. Conclusion
Dangling pointers and null pointers can lead to serious bugs and undefined behavior. Proper handling techniques, such as smart pointers and explicit null checks, improve memory safety and prevent crashes.