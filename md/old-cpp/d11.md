### 1. Introduction
Recursion is a programming technique where a function calls itself to solve smaller instances of a problem. It is useful for problems that can be broken down into similar subproblems, such as tree traversal, factorial calculation, and the Fibonacci sequence.

### 2. Structure of a Recursive Function
A recursive function typically consists of:
- **Base case**: The condition that stops recursion.
- **Recursive case**: The function calls itself with a modified argument.

**Example:**
```c
#include <iostream>
using namespace std;

void recursiveFunction(int count) {
    if (count == 0) return; // Base case
    cout << "Recursion level: " << count << endl;
    recursiveFunction(count - 1); // Recursive case
}

int main() {
    recursiveFunction(5);
    return 0;
}
```

### 3. Factorial Using Recursion
Factorial of `n` (denoted as `n!`) is defined as:
```
n! = n × (n - 1) × ... × 1
```

**Example:**
```c
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) return 1; // Base case
    return n * factorial(n - 1); // Recursive case
}

int main() {
    int num = 5;
    cout << "Factorial of " << num << " is " << factorial(num) << endl;
    return 0;
}
```

### 4. Fibonacci Sequence Using Recursion
The Fibonacci sequence is defined as:
```
F(n) = F(n-1) + F(n-2), where F(0) = 0, F(1) = 1
```

**Example:**
```c
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) return n; // Base cases
    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case
}

int main() {
    int num = 6;
    cout << "Fibonacci(" << num << ") = " << fibonacci(num) << endl;
    return 0;
}
```

### 5. Direct vs. Indirect Recursion
#### **Direct Recursion**
A function calls itself directly.

**Example:**
```c
void directRecursion(int n) {
    if (n == 0) return;
    cout << n << " ";
    directRecursion(n - 1);
}
```

#### **Indirect Recursion**
A function calls another function that eventually calls the original function.

**Example:**
```c
void functionA(int n);
void functionB(int n);

void functionA(int n) {
    if (n <= 0) return;
    cout << n << " ";
    functionB(n - 1);
}

void functionB(int n) {
    if (n <= 0) return;
    functionA(n - 2);
}

int main() {
    functionA(5);
    return 0;
}
```

### 6. Tail Recursion
Tail recursion occurs when the recursive call is the last statement in the function.

**Example:**
```c
void tailRecursion(int n) {
    if (n == 0) return;
    cout << n << " ";
    tailRecursion(n - 1); // Last operation before return
}
```

### 7. Advantages and Disadvantages of Recursion
#### **Advantages**
- Simplifies complex problems.
- Easier to read and maintain for divide-and-conquer problems.
- Reduces the need for explicit loops.

#### **Disadvantages**
- Can lead to stack overflow if the base case is not reached.
- Higher memory usage due to function call stack.
- Often less efficient than iterative solutions.

### 8. When to Use Recursion
Recursion is best suited for:
- Tree and graph traversals (e.g., DFS, BFS)
- Divide-and-conquer algorithms (e.g., Merge Sort, Quick Sort)
- Problems with a naturally recursive structure (e.g., Tower of Hanoi)

---
Understanding recursion is essential for problem-solving in C++. Using recursion effectively can lead to cleaner and more elegant solutions.

