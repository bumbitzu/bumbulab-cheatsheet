**Smart Pointers in C++ (`unique_ptr`, `shared_ptr`, `weak_ptr`)**

### 1. Introduction
Smart pointers are a feature of C++ introduced in the **C++11** standard. They manage dynamic memory automatically, reducing memory leaks and simplifying resource management.

### 2. Types of Smart Pointers
C++ provides three types of smart pointers in the `<memory>` library:
- `unique_ptr` – Sole ownership of an object.
- `shared_ptr` – Shared ownership of an object.
- `weak_ptr` – Non-owning reference to a `shared_ptr`.

### 3. `unique_ptr`
`unique_ptr` is a smart pointer that has **exclusive ownership** of an object. When it goes out of scope, the object is automatically deleted.

#### **3.1 Creating a `unique_ptr`**
```c
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> ptr = make_unique<int>(10);
    cout << "Value: " << *ptr << endl;
    return 0; // ptr automatically deletes the allocated memory
}
```

#### **3.2 Transferring Ownership with `std::move`**
```c
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> ptr1 = make_unique<int>(20);
    unique_ptr<int> ptr2 = move(ptr1); // Transfers ownership
    
    if (!ptr1) {
        cout << "ptr1 is now empty" << endl;
    }
    cout << "Value in ptr2: " << *ptr2 << endl;
    return 0;
}
```

### 4. `shared_ptr`
`shared_ptr` allows **multiple pointers** to share ownership of the same object. The object is deleted when the last `shared_ptr` goes out of scope.

#### **4.1 Creating and Using `shared_ptr`**
```c
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> ptr1 = make_shared<int>(30);
    shared_ptr<int> ptr2 = ptr1; // Shared ownership
    
    cout << "Reference Count: " << ptr1.use_count() << endl;
    return 0;
}
```

### 5. `weak_ptr`
`weak_ptr` is a non-owning reference to a `shared_ptr`. It prevents cyclic dependencies that can lead to memory leaks.

#### **5.1 Using `weak_ptr`**
```c
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> sptr = make_shared<int>(50);
    weak_ptr<int> wptr = sptr; // Does not increase reference count
    
    if (auto temp = wptr.lock()) { // Checks if resource is still available
        cout << "Value: " << *temp << endl;
    } else {
        cout << "Resource expired" << endl;
    }
    return 0;
}
```

### 6. Summary
| Smart Pointer | Ownership | Reference Count | Use Case |
|--------------|-----------|-----------------|----------|
| `unique_ptr` | Exclusive | No reference count | Resource ownership with strict lifetime management |
| `shared_ptr` | Shared | Yes | Shared ownership, avoids raw pointers |
| `weak_ptr` | No ownership | References a `shared_ptr` | Avoids circular references |

### 7. Conclusion
Smart pointers improve memory management by handling automatic deallocation. Using `unique_ptr`, `shared_ptr`, and `weak_ptr` effectively prevents memory leaks and ensures safe dynamic memory usage.

