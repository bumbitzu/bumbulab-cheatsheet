### 1. Introduction
Dynamic memory allocation allows programs to allocate memory at runtime, enabling efficient use of memory resources.

### 2. Allocating Memory with `new`
The `new` operator dynamically allocates memory on the heap and returns a pointer to the allocated memory.

#### **2.1 Allocating a Single Variable**
```c
#include <iostream>
using namespace std;

int main() {
    int* ptr = new int(10); // Allocate memory for an integer
    cout << "Value: " << *ptr << endl;
    delete ptr; // Deallocate memory
    return 0;
}
```

### 3. Allocating Memory for Arrays
The `new` operator can also allocate memory for arrays dynamically.

#### **3.1 Allocating an Array Dynamically**
```c
#include <iostream>
using namespace std;

int main() {
    int* arr = new int[5]; // Allocate an array of 5 integers
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    delete[] arr; // Deallocate array memory
    return 0;
}
```

### 4. Deallocating Memory with `delete`
The `delete` operator releases memory allocated with `new`.
- Use `delete` for single variables.
- Use `delete[]` for arrays.

#### **4.1 Incorrect Deallocation**
```c
int* ptr = new int[5];
delete ptr; // Incorrect! Should use delete[]
```

#### **4.2 Correct Deallocation**
```c
int* ptr = new int[5];
delete[] ptr; // Correct way to free array memory
```

### 5. Memory Leaks and Best Practices
- **Always free memory** using `delete` or `delete[]`.
- **Avoid memory leaks** by properly deallocating unused memory.
- **Initialize pointers** to `nullptr` after deletion to prevent dangling pointers.

**Example:**
```c
int* ptr = new int(100);
delete ptr;
ptr = nullptr; // Prevents dangling pointer issue
```

### 6. Conclusion
Dynamic memory allocation enables flexible memory management in C++. Proper handling using `new` and `delete` ensures efficient resource management and prevents memory leaks.