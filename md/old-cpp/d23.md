### 1. Virtual Functions
Virtual functions allow derived classes to override a function from the base class, enabling **runtime polymorphism**.

#### **1.1 Declaring a Virtual Function**
- Use the `virtual` keyword in the base class.
- The function is overridden in the derived class.
- The function call is resolved at runtime using a **vtable**.

**Example:**
```c
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void makeSound() {
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* animal = new Dog();
    animal->makeSound(); // Calls Dog's makeSound()
    delete animal;
    return 0;
}
```

### 2. Pure Virtual Functions and Abstract Classes
A **pure virtual function** is a function that must be implemented by derived classes, making the base class an **abstract class**.

#### **2.1 Declaring a Pure Virtual Function**
- Use `= 0` in the base class function declaration.
- Objects of abstract classes **cannot** be instantiated.

**Example:**
```c
#include <iostream>
using namespace std;

class Shape {
public:
    virtual void draw() = 0; // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing Circle" << endl;
    }
};

int main() {
    Shape* shape = new Circle();
    shape->draw();
    delete shape;
    return 0;
}
```

### 3. Key Differences Between Virtual Functions and Abstract Classes
| Feature | Virtual Function | Abstract Class |
|---------|----------------|---------------|
| Definition | A function in a base class that can be overridden | A class that has at least one pure virtual function |
| Object Instantiation | Can create objects of base class | Cannot instantiate directly |
| Purpose | Enables runtime polymorphism | Serves as a blueprint for derived classes |

### 4. Best Practices
- Use virtual functions when designing polymorphic behavior.
- Use abstract classes when creating a common interface for multiple derived classes.
- Always **declare destructors as virtual** in base classes to ensure proper cleanup of derived objects.

**Example of Virtual Destructor:**
```c
class Base {
public:
    virtual ~Base() {}
};
```

### 5. Conclusion
Virtual functions enable **dynamic method dispatch**, while abstract classes enforce **implementation in derived classes**. Understanding these concepts is crucial for writing scalable and maintainable C++ programs.