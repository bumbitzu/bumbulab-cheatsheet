### 1. Introduction
Trees, graphs, hash tables, and heaps are fundamental data structures used for hierarchical, networked, and efficient key-value relationships in C++. Trees provide structured data representation, graphs model complex relationships, hash tables allow fast lookups, and heaps manage priority-based operations.

---

### 2. Trees
A **tree** is a hierarchical data structure consisting of nodes where each node has a parent and zero or more children. The root node is the topmost node, and leaves are nodes with no children.

#### **2.1 Binary Tree Implementation**
```c
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

class BinaryTree {
public:
    Node* root;
    BinaryTree() : root(nullptr) {}
    
    void inorderTraversal(Node* node) {
        if (node == nullptr) return;
        inorderTraversal(node->left);
        cout << node->data << " ";
        inorderTraversal(node->right);
    }
};

int main() {
    BinaryTree tree;
    tree.root = new Node(10);
    tree.root->left = new Node(5);
    tree.root->right = new Node(15);
    
    cout << "Inorder Traversal: ";
    tree.inorderTraversal(tree.root);
    cout << endl;
    return 0;
}
```

---

### 3. Graphs
A **graph** is a collection of nodes (vertices) connected by edges. It can be **directed** (edges have direction) or **undirected** (edges have no direction).

#### **3.1 Graph Representation Using Adjacency List**
```c
#include <iostream>
#include <vector>
using namespace std;

class Graph {
public:
    int vertices;
    vector<vector<int>> adjList;
    
    Graph(int v) : vertices(v), adjList(v) {}
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // Remove this for a directed graph
    }
    
    void displayGraph() {
        for (int i = 0; i < vertices; i++) {
            cout << "Vertex " << i << " -> ";
            for (int neighbor : adjList[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 3);
    g.addEdge(3, 4);
    
    g.displayGraph();
    return 0;
}
```

---

### 4. Hash Tables
A **hash table** is a data structure that stores key-value pairs using a hash function to compute an index.

#### **4.1 Implementing a Hash Table Using `unordered_map`**
```c
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> hashTable;
    hashTable["apple"] = 10;
    hashTable["banana"] = 20;
    hashTable["orange"] = 30;
    
    cout << "Apple Price: " << hashTable["apple"] << endl;
    return 0;
}
```

---

### 5. Heaps
A **heap** is a special tree-based structure that satisfies the heap property (max-heap or min-heap).

#### **5.1 Implementing a Min-Heap Using `priority_queue`**
```c
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int, vector<int>, greater<int>> minHeap;
    minHeap.push(10);
    minHeap.push(5);
    minHeap.push(15);
    
    cout << "Min Element: " << minHeap.top() << endl;
    return 0;
}
```

---

### 6. Summary
| Data Structure | Definition | Use Cases |
|---------------|------------|----------|
| Binary Tree | Hierarchical structure with parent-child nodes | Searching, sorting, hierarchical data |
| Graph | Nodes connected by edges | Social networks, maps, pathfinding |
| Hash Table | Key-value storage for fast lookups | Caching, databases, indexing |
| Heap | Priority-based tree structure | Scheduling, priority queues |

---

### 7. Conclusion
Trees, graphs, hash tables, and heaps provide powerful ways to structure data efficiently. Understanding their implementation and traversal techniques is crucial for solving complex computational problems in C++.