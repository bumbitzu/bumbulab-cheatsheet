
### 1. Introduction
Linked lists, stacks, and queues are fundamental data structures in C++ used for efficient data storage, retrieval, and manipulation. These structures help optimize operations like insertion, deletion, and traversal based on specific requirements.

---

### 2. Linked Lists
A **linked list** is a dynamic data structure consisting of nodes where each node contains data and a pointer to the next node. Unlike arrays, linked lists provide efficient memory usage and allow dynamic resizing.

#### **2.1 Implementing a Singly Linked List**
```c
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
public:
    Node* head;
    LinkedList() : head(nullptr) {}

    void insert(int val) {
        Node* newNode = new Node(val);
        newNode->next = head;
        head = newNode;
    }

    void display() {
        Node* temp = head;
        while (temp) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }

    void deleteNode(int key) {
        Node* temp = head, *prev = nullptr;
        while (temp && temp->data != key) {
            prev = temp;
            temp = temp->next;
        }
        if (!temp) return;
        if (!prev) head = temp->next;
        else prev->next = temp->next;
        delete temp;
    }
};

int main() {
    LinkedList list;
    list.insert(10);
    list.insert(20);
    list.insert(30);
    list.display();
    list.deleteNode(20);
    list.display();
    return 0;
}
```

---

### 3. Stacks
A **stack** is a Last-In-First-Out (LIFO) data structure where elements are added and removed from the top.

#### **3.1 Implementing a Stack Using an Array**
```c
#include <iostream>
#define MAX 100
using namespace std;

class Stack {
private:
    int top;
    int arr[MAX];
public:
    Stack() : top(-1) {}
    bool isEmpty() { return top == -1; }
    bool isFull() { return top == MAX - 1; }
    void push(int val) {
        if (isFull()) {
            cout << "Stack Overflow" << endl;
            return;
        }
        arr[++top] = val;
    }
    void pop() {
        if (isEmpty()) {
            cout << "Stack Underflow" << endl;
            return;
        }
        top--;
    }
    int peek() {
        return isEmpty() ? -1 : arr[top];
    }
};

int main() {
    Stack s;
    s.push(10);
    s.push(20);
    cout << "Top: " << s.peek() << endl;
    s.pop();
    cout << "Top: " << s.peek() << endl;
    return 0;
}
```

---

### 4. Queues
A **queue** is a First-In-First-Out (FIFO) data structure where elements are added at the rear and removed from the front.

#### **4.1 Implementing a Queue Using an Array**
```c
#include <iostream>
#define MAX 100
using namespace std;

class Queue {
private:
    int front, rear;
    int arr[MAX];
public:
    Queue() : front(0), rear(-1) {}
    bool isEmpty() { return front > rear; }
    bool isFull() { return rear == MAX - 1; }
    void enqueue(int val) {
        if (isFull()) {
            cout << "Queue Overflow" << endl;
            return;
        }
        arr[++rear] = val;
    }
    void dequeue() {
        if (isEmpty()) {
            cout << "Queue Underflow" << endl;
            return;
        }
        front++;
    }
    int peek() {
        return isEmpty() ? -1 : arr[front];
    }
};

int main() {
    Queue q;
    q.enqueue(10);
    q.enqueue(20);
    cout << "Front: " << q.peek() << endl;
    q.dequeue();
    cout << "Front: " << q.peek() << endl;
    return 0;
}
```

---

### 5. Summary
| Data Structure | Type | Access Time | Operations |
|--------------|--------|--------------|-------------------|
| Linked List | Dynamic | O(n) for search | Insert/Delete: O(1) |
| Stack | LIFO | O(1) for push/pop | Push/Pop: O(1) |
| Queue | FIFO | O(1) for enqueue/dequeue | Enqueue/Dequeue: O(1) |

---

### 6. Advantages and Disadvantages
#### **Linked Lists**
**Advantages:**
- Dynamic memory allocation, no size limit.
- Efficient insertions and deletions.

**Disadvantages:**
- Slower search (O(n)).
- Extra memory required for pointers.

#### **Stacks**
**Advantages:**
- Efficient LIFO operations.
- Used in function calls, expression evaluation.

**Disadvantages:**
- Limited by memory size.
- No direct access to elements.

#### **Queues**
**Advantages:**
- FIFO ensures fair processing.
- Useful for scheduling tasks.

**Disadvantages:**
- Fixed-size arrays limit capacity.
- Dequeues require shifting elements in arrays.

---

### 7. Conclusion
Understanding linked lists, stacks, and queues is crucial for designing efficient algorithms. Each data structure has unique properties suited to different applications, such as stacks for backtracking and queues for scheduling. By leveraging these structures effectively, developers can improve data processing performance in C++ applications.

