Functions are fundamental building blocks in C++ that allow code reuse, organization, and modularity. They make the code easier to read, debug, and maintain by breaking complex problems into smaller, manageable parts.

### 1. Defining a Function
A function consists of a return type, a name, parameters (optional), and a body. Functions can return a value or be `void` if no value needs to be returned.

**Syntax:**
```c
return_type function_name(parameters) {
    // Function body
    return value; // Optional, depending on return_type
}
```

**Example:**
```c
#include <iostream>
using namespace std;

// Function definition
int add(int a, int b) {
    return a + b;
}

int main() {
    int sum = add(5, 3);
    cout << "Sum: " << sum << endl;
    return 0;
}
```

### 2. Function Declaration (Prototype)
A function can be declared before it is defined. This is useful for organizing code in header files and ensuring function availability before its implementation.

**Syntax:**
```c
return_type function_name(parameters); // Function prototype
```

**Example:**
```c
#include <iostream>
using namespace std;

// Function prototype
int multiply(int, int);

int main() {
    cout << "Product: " << multiply(4, 2) << endl;
    return 0;
}

// Function definition
int multiply(int a, int b) {
    return a * b;
}
```

### 3. Function Parameters and Arguments
Functions can accept parameters of different types. Passing parameters allows data to be reused without needing global variables.

**Example with multiple parameters:**
```c
#include <iostream>
using namespace std;

void greet(string name, int age) {
    cout << "Hello, " << name << "! You are " << age << " years old." << endl;
}

int main() {
    greet("Alice", 25);
    return 0;
}
```

### 4. Function Overloading
Functions can have the same name but different parameters (number or type). This is useful when the same operation needs to be performed on different types of data.

**Example:**
```c
#include <iostream>
using namespace std;

// Overloaded functions
int square(int x) {
    return x * x;
}

double square(double x) {
    return x * x;
}

int main() {
    cout << "Square of 4: " << square(4) << endl;
    cout << "Square of 5.5: " << square(5.5) << endl;
    return 0;
}
```

### 5. Default Parameters
Functions can have default values for parameters, allowing them to be called with fewer arguments. Default values are defined in the function declaration.

**Example:**
```c
#include <iostream>
using namespace std;

void displayMessage(string message = "Hello, World!") {
    cout << message << endl;
}

int main() {
    displayMessage(); // Uses default value
    displayMessage("Custom Message"); // Uses provided value
    return 0;
}
```

### 6. Recursive Functions
A function that calls itself is known as a recursive function. Recursion is useful for problems like calculating factorials, Fibonacci sequences, and tree traversals.

**Example:**
```c
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

int main() {
    cout << "Factorial of 5: " << factorial(5) << endl;
    return 0;
}
```

### 7. Pass by Value vs. Pass by Reference
#### **Pass by Value**
A copy of the argument is passed to the function, meaning changes inside the function do not affect the original variable.

**Example:**
```c
void modify(int x) {
    x = 10;
}
```

#### **Pass by Reference**
The actual variable is passed, allowing modifications inside the function to reflect outside.

**Example:**
```c
void modify(int &x) {
    x = 10;
}
```

### 8. Inline Functions
Inline functions can be defined using the `inline` keyword to reduce function call overhead, improving performance.

**Example:**
```c
inline int square(int x) {
    return x * x;
}
```

### 9. Lambda Functions
C++ supports anonymous functions (lambdas) using the `[]` syntax, which are useful for short, temporary functions.

**Example:**
```c
#include <iostream>
using namespace std;

int main() {
    auto add = [](int a, int b) { return a + b; };
    cout << "Lambda Sum: " << add(5, 3) << endl;
    return 0;
}
```

---
Mastering function definitions and calls is essential for writing efficient and modular C++ programs. Understanding different types of function handling, including recursion, overloading, and lambda functions, helps create clean and optimized code.

