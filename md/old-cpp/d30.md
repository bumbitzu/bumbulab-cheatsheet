### 1. Introduction
A **memory leak** occurs when dynamically allocated memory is not properly deallocated, leading to increased memory usage and potential crashes in long-running programs.

### 2. Causes of Memory Leaks
- **Forgetting to free dynamically allocated memory**
- **Overwriting pointers without deleting old memory**
- **Losing all references to allocated memory**
- **Improper use of dynamic arrays**

### 3. Example of a Memory Leak
```c
#include <iostream>
using namespace std;

void memoryLeak() {
    int* ptr = new int(10); // Dynamically allocated memory
    // No delete statement -> Memory leak
}

int main() {
    memoryLeak();
    return 0;
}
```

### 4. Detecting Memory Leaks
- **Manual code review**
- **Using tools like Valgrind (Linux), AddressSanitizer (Clang/GCC), or Visual Leak Detector (Windows)**

**Example: Running Valgrind**
```sh
valgrind --leak-check=full ./a.out
```

### 5. Preventing Memory Leaks
#### **5.1 Properly Deallocating Memory**
```c
void noMemoryLeak() {
    int* ptr = new int(10);
    delete ptr; // Proper cleanup
}
```

#### **5.2 Using Smart Pointers**
Smart pointers (`unique_ptr`, `shared_ptr`) automatically deallocate memory when they go out of scope.
```c
#include <memory>
using namespace std;

void useSmartPointer() {
    unique_ptr<int> ptr = make_unique<int>(10);
}
```

#### **5.3 Avoiding Unnecessary Heap Allocation**
Prefer stack allocation over heap allocation whenever possible.
```c
void useStack() {
    int num = 10; // No dynamic memory allocation required
}
```

### 6. Summary
| Issue | Solution |
|-------|----------|
| Forgetting to delete memory | Use `delete` or smart pointers |
| Overwriting pointer | Assign `nullptr` after `delete` |
| Losing reference to memory | Avoid unnecessary heap allocation |

### 7. Conclusion
Memory leaks can severely impact application performance. Proper memory management techniques, such as using smart pointers and proper deallocation, help mitigate these issues effectively.

